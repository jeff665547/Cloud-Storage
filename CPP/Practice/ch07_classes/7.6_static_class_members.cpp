// Static Class Members
// * Classes sometimes need members that are associated with the class,
//   rather than with individual objects of the class type.
// * 有些class的成員是和整個類有關聯的而不是和使用類創造出來的個別物件(*this)有關聯，
//   此時就需要static class members。
// * Example: the current prime interest rate in a bank account class. In this 
//   case, if the rate changes, we'd want each account object to use the new value.
# include <iostream>

class Account{
public:
    // member function can use static members directly, without the scope operator.
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void get_int_value() { get_private(); }
    static void rate(double);
    static int test_public;
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();

    // In-class initialization of static Data Members
    // static 資料成員屬於類別，而非個別實例，想在類別內初始 static 資料成員的話，
    // 必須是個 constexpr，也就是必須是編譯時期常數，若否，必須在類別外指定。
    // * In general, class static members may not be initialized in the class body.
    // * we can provide in-class initializers for static members that have const integral type and must do
    //   so for static members that are constexprs of literal type.
    // * If an initializer is provided inside the class, the member's function must not specify an initial value.
    // * Literal types: because a constant expression is one that can be evaluated at compile time,
    //   there are limits on the types that we can use in a constexpr declaration. The types we can use in 
    //   a constexpr are known as "literal types" because they are simple enough to have literal values.
    // * Literal types such as char, bool , etc., and arithmetic, reference, and pointer types.
    // * Here is an example to use an initialized static data member to specify the dimension of an array member.
    static constexpr int period = 30; // priod is a constant expression. The initializers 
                                      // (consists of the expression "=" and the terms following the "=") 
                                      // must be a constant expressions.
    double daily_tbl[period];
    
    static int test_private;
    static void get_private();

};
// * static members can be public or private.
// * The type of a static data member can be const, reference, array, class type, and ... so on.
// * static members of a class exist outside any object. Objects do not contain data associatd with static data members.
// * In this example above, Account object generated by the Account class will contain two data members: owner and amount.
// * There is only one data member "interestRate" will be shared by all the Account objects.
// * Static member functions may not be declared as const (const member function will read the member but not change the value), 
//   and we may not refer to "this" in the body of a static member. 
//   (no matter whether we call "this" or not.)
// * 呼叫靜態函式時，並不會傳入實例位址，也就是 static 函式中不會有 this 指標，
//   因此 static 函式中不允許使用非 static 成員，因為沒有 this 可以使用。


// Defining static Members
// * We can define a static member function inside or outside of the class body.
// * The static keyword is used only on the declaration inside the class body.
void Account::rate(double newRate){
    interestRate = newRate;
}

// * In general, we may not initialize a static member inside the class.
// * Instead, we must define and initialize each static data member outside the class body.
// * Like any other object, a static data member may be defined only once.
double Account::interestRate = initRate();
double Account::initRate(){
    return 0.05;
}

// this is okay even though test_private is private since it's a definition
int Account::test_public = 5;
int Account::test_private = 10;
//  If no initializer is provided, C++ initializes the value to 0.
//  Do not put the static member definition in a header file 
//  (much like a global variable, if that header file gets included more than once, 
//  you’ll end up with multiple definitions, which will cause a compile error).

void Account::get_private(){
    std::cout << test_private << std::endl;
}

// ================================================================================================= //
// Another Example
class Something
{
private:
    static int s_idGenerator;
    int m_id;
 
public:
    Something() { m_id = s_idGenerator++; } // grab the next value from the id generator
    // i++ means add i after returning i.
 
    int getID() const { return m_id; }
};
 
// Note that we're defining and initializing s_idGenerator even though it is declared as private above.
// This is okay since the definition isn't subject to access controls.
int Something::s_idGenerator = 1; // start our ID generator with value 1

// ================================================================================================= //
// Another Example
// 在此範例裡面說明了，只有static members 可以當別人的 default argument，其他一般的members當別人的default argument時會產生錯誤
class Screen {
public:
    // bkground refers to the static member
    // declared later in the class definition
    void clear(int = bkground);
    int tempp(){ return bkground/2; }
private:
    static int bkground;  // error: if it is "int bkground;"
};

// ================================================================================================= //
// Another Example
// * Static member can have incomplete type.
struct _tie{
    int value;
};
typedef struct _tie tie;

class Bar{
public:
    int value;
private:
    static tie mem1;  // ok: "tie" is a complete type. static member can have complete type.
    tie *mem2;        // ok: "tie" is a complete type. pointer member can have complete type.
    tie mem3;         // ok: "tie" is a complete type. data member must have complete type.
    int mem4;         
    static Bar mem5;  // ok: static member can have incomplete type "Bar".
    Bar *mem6;        // ok: pointer member can have incomplete type "Bar".
    // Bar mem7;      // error: data members must have complete type "Bar".
};

int main(){

    // Using a class static member.
    double r;
    
    Account ac1;
    Account *ac2 = &ac1;
    // equivalent ways to call the static member rate function.
    r = ac1.rate();  // through an Account object or reference.
    r = ac2->rate();  // through a pointer to an Account object.
    // The following way is the preferred method for accessing static members.
    std::cout << Account::rate() << std::endl;
    std::cout << Account::test_public << std::endl;
    // std::cout << Account::test_private << std::endl;  // compile error: declared private here
    Account::get_int_value();
    
    // ================================================================================================ //
    // Second Example
    Something first;
    Something second;
    Something third;

    std::cout << first.getID() << '\n';
    std::cout << second.getID() << '\n';
    std::cout << third.getID() << '\n';
    
    // Because s_idGenerator is shared by all Something objects, 
    // when a new Something object is created, the constructor grabs
    // the current value out of s_idGenerator and then increments the value for the next object. 
    // This guarantees that each instantiated Something object receives a unique id 
    // (incremented in the order of creation).

    // Static member variables can also be useful when the class needs to utilize an internal lookup table 
    // (e.g. an array used to store a set of pre-calculated values). 
    // By making the lookup table static, only one copy exists for all objects, 
    // rather than making a copy for each object instantiated. This can save substantial amounts of memory.

    

    return 0;
}