# include <iostream>
// Inheritance 繼承
//
// 公開繼承 (public)
// * 假設您先前已經撰寫了一些2D繪圖相關類別，
//   現在打算將之擴充為適用於3D繪圖，
//   3D的觀念是2D的延伸，
//   許多2D繪圖時所使用的功能都可以留下來加以擴充，
//   在C++中您不用重寫所有的類別，
//   您可以「繼承」（Inherit）原先已定義好的類別，
//   然後加以擴充。 
//
// * 例如: 繪圖中最基本的點類別，
//   您原先已定義好一個Point2D類別，
//   您繼承它並將之擴充為Point3D類別，
//   在繼承的關係中，
//   稱被繼承的類別為「父類別」（Parent class）
//   或「基礎類別」（Base class），
//   而繼承父類別的就稱之為「子類別」（Child class）
//   或「衍生類別」（Derived class），
//   在繼承時您使用 : 運算子，
//   並指定其繼承方式，在繼承的權限關係上，
//   公開繼承是最常見的。
//
// * 公開繼承時，
//   父類別與子類別之間是"is-a"的關係，
//   白話來說，假設父類別是A類的話，
//   公開繼承的子類也「是一種」A類。
//
// e.g.
class Point2D{
    public:
        Point2D(){
            _x = 0;
            _y = 0;
        }
        // Point2D(int x, int y){
        //     _x = x;
        //     _y = y;
        // }
        // 下方寫法和上方寫法的結果是一樣的，但就效率而言下方較好，
        // 因為下方是直接在建構的時候就同時賦予值，然而上方的寫法則是
        // 先建立一個空的變數，再去賦值。
        // 下方寫法被稱為成員初始化列表
        // (Member Initialization List)
        Point2D(int x, int y)
        :   _x(x),
            _y(y)
        {
            // 增加一些須做的動作
        }
        int x() {
            return _x;
        }
        int y() {
            return _y;
        }
        void x(int x) {
            _x = x;
        }
        void y(int y) {
            _y = y;
        }

    private:
        int _x;
        int _y;
};

// 受保護的(protected)成員
//
// * 在之前的範例中，類別的資料成員多設定為private成員，
//   也就是私用成員，私用成員只能在類別物件中使用，
//   不能直接透過物件來呼叫使用，
//   而即使是繼承了該類別的衍生類別也是如此，
//   您只能透過該類別所提供的public函式成員來呼叫或設定私用成員。
//
// * 然而有些時候，您希望繼承了基底類別的衍生類別，
//   能夠直接存取呼叫基底類別中的成員，但不是透過public函式成員，
//   也不是將它宣告為public，因為您仍不希望這些成員被物件直接呼叫使用。
//
// * 可以宣告這些成員為「受保護的成員」(protected member)，
//   保護的意思表示存取它是有條件限制的以保護該成員，
//   當您將類別成員宣告為受保護的成員之後，
//   繼承它的類別就可以直接使用這些成員，
//   但這些成員仍然受到類別的保護，不可被物件直接呼叫使用。
//
// * 要宣告一個成員成為受保護的成員，
//   就使用"protected"關鍵字，並將成員宣告於它的下方，
//   下面這個程式是個實際的例子，您將資料成員宣告為受保護的成員，
//   繼承它的類別就可以直接使用，而不用透過public函式成員來呼叫，
//   這可以省去一些函式呼叫所帶來的負擔
//
// e.g.
class Rectangle{
    public: 
        Rectangle(){
            _x = 0;
            _y = 0;
            _width = 0;
            _height = 0;
        }

        Rectangle(int x, int y, int width, int height)
        : _x(x), _y(y), _width(width), _height(height)
        {
        }

        int x(){
            return _x;
        }
        int y(){
            return _y;
        }
        int width(){
            return _width;
        }
        int height(){
            return _height;
        }
        int area(){
            return _width*_height;
        }
    

    // 受保護的member
    protected:
        int _x;
        int _y;
        int _width;
        int _height;
};


// 成員函式的重新定義
// * 如果基底類別中定義了一個函式，當您繼承了基底類別之後，
//   您可以「重新定義」(Override)這個函式，
//   以讓它適用於衍生類別。
// * 如下所示，當同一個成員函式在衍生類別中被重新定義，
//   使用此衍生類別所生成的物件來呼叫該函式，
//   所執行的會是衍生類別中所定義的函式，
//   而基底類別中的同名函式並不受影響。

class Fool {
    public:
        void show(){
            std::cout << "Fool's show()" << std::endl;
        }
};

class Fool2 : public Fool {
    public:
        void show(){
            std::cout << "Fool2's show()" << std::endl;
        }
};

// 繼承後的建構函式與解構函式
// * 若您繼承了某個類別之後，當您在生成衍生類別的物件時若不指定參數，
//   無參數的預設建構子會被執行，而基礎類別的無參數預設建構子也會被執行，
//   所以基於這種特性，通常預設建構子中會撰寫一些通用的成員狀態初始，
//   例如設定一些預設值。
// * 如果您使用衍生類別生成物件，
//   則建構函式的執行順序會從基底類別的建構函式開始執行起，
//   這是可以理解的，因為基底類別是衍生類別的基礎，
//   一些基礎的參數或初始狀態必須先完成，
//   再來再完成衍生類別中的建構函式。
// * 而在物件被消滅時，解構函式的執行順序則正好相反，
//   是從衍生類別的解構函式開始執行，再來才是基礎類別的建構函式，
//   因為若基底類別的解構函式如果先執行，
//   則衍生類別相依於基底類別的一些狀態也會被解構（例如指標），
//   則此時再行衍生類別的解構函式，將存在著相依問題而造成錯誤。
// e.g. example在main.cpp中

// 保護繼承 (protected) & 私用繼承 (private)
//
// * 在繼承時採公開(public)繼承的方式來繼承一個類別時，
//   父類別與子類別為"is-a"的關係，
//   子類別繼承父類別的公開(public)介面及受保護(protected)的成員，
//   子類別是父類別的細化型態。
//
// * 保護(protected)繼承可以改變繼承下來的基底類別成員權限，
//   保護的意思就是讓這些成員繼承下來之後，
//   保護它們僅能在類別與衍生類別中使用。
//       基底類別        衍生類別
//       private        不繼承
//       protected      protected
//       public         protected
//
//    簡單的說，原來的權限在protected以下的保留其原來權限，
//    而在protected以上的就降為protected，
//    子類別protected繼承的目的在只希望保留父類別中已實作的公開成員與受保護的成員為己用或接下來的衍生類別使用，
//    並提供自己的公開介面。
//
// * 也可以在繼承基底類別之後，將它所有的成員一律改為私用(private)，
//   使用私用(private)繼承可以達到這個目的。
//       基底類別        衍生類別
//       private         不繼承
//       protected       private
//       public          private
//     private繼承被稱為「實作繼承」，意味著子類別只想保留父類別中已實作的公開與受保護的成員為己用，
//     並提供自己的公開介面與接下來會被繼承的受保護的成員。