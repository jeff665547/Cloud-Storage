// 進階的影像處理，就是表示
// 使用影像結構中所定義的高層處理方法來完成特殊任務。
// 而些任務，就是圖形和視覺範疇的任務。
// 
/* 平滑處理 */
// 平滑處理(smoothing)也稱為模糊處理(bluring)，
// 是一種簡單而且使用頻率很高的影像處理方法。
// 平滑處理用途有很多，最常見的是用來減少影像上的噪點或失真。
// 在涉及到降低影像解析度時，平滑處理是非常好用的方法。
// 
// 影像濾波與濾波器
// * 影像濾波，指在盡量保留影像細節特徵的條目下對目標影像的雜訊進行抑制，
//   是影像預處理中不可或缺的操作，其處理效果的好壞將直接影響到後續影像處理
//   和分析的有效性和可靠性。
// * 消除影像中的雜訊成分叫做影像的平滑化或濾波操作。
// * 信號或影像的能量大部分集中在幅度譜的低頻或中頻段，
//   而在較高頻段，有用的資訊經常被雜訊淹沒。
//   因此，一個能降低高頻成分幅度的濾波器就能夠減弱雜訊的影響。
// * 影像濾波的目的:
//   1. 抽出物件的特徵作為影像識別的特徵模式。
//   2. 為適應影像處理的要求，消除影像數位化時所混入的雜訊。
// * 濾波處理的要求:
//   1. 不能損壞影像的輪廓及邊緣等重要資訊。
//   2. 使影像清晰視覺效果好。
// * 平滑濾波是低頻低頻增強的空間域濾波技術。其目的為:
//   1. 模糊
//   2. 消除噪音
// 
// 空間域的平滑濾波一般採用簡單平均法進行。就是求鄰近像素點的平均亮度值。
// 鄰域的大小與平滑的效果直接相關，鄰域越大平滑效果越好，但鄰域過大， 平滑效果
// 也會使邊緣資訊損失的越大，從而使輸出的影像變得模糊，因此需合理選擇鄰域的大小。
// 
// 濾波器，一種具體的比喻是:可以把濾波器想像成一個包含加權係數的視窗，
// 當使用這個濾波器模糊處理影像時，就把這個視窗放到影像之上，透過這個視窗
// 來看我們得到的影像。
// 
// 濾波器的種類有很多:
// 1. (線性)方框濾波器: BoxBlur函數
// 2. (線性)均值濾波器(鄰域平均濾波): Blur函數
// 3. (線性)高斯濾波器: GaussianBlur函數
// 4. (非線性)中值濾波器: medianBlur函數
// 5. (非線性)雙邊濾波器: bilateralFilter函數
// 
// * 線性濾波器經常用於剔除輸入信號中不想要的頻率，或者從眾多頻率中選擇一個想要的頻率。
// * 常見的線性濾波器:
// 1. 低通濾波器(Low-pass filter): 允許低頻率通過。
// 2. 高通濾波器(High-pass filter): 允許高頻率通過。
// 3. 帶通濾波器(Bnad-Pass filter): 允許一定範圍頻率通過。
// 4. 帶阻濾波器(bandstop filter): 阻止一定範圍頻率通過，並且允許其他頻率通過。
// 5. 全通濾波器(All Pass filter): 允許所有頻率通過，僅僅改變相位關係。
// 6. 陷波濾波器(Band-Stop filter): 阻止一個狹窄頻率範圍通過，是一種特殊帶阻濾波器。
// 
// 濾波 vs. 模糊
// * 濾波是將信號中特定波段頻率濾除的操作，是抑制和防止干擾的一項重要措施。
// * 濾波可分低通濾波和高通濾波兩種:
//   高斯濾波是指用高斯函數作為濾波函數的濾波操作，若是高通就是銳利化，而低通就是模糊。
//   因此，高斯模糊就是高斯低通濾波，高斯濾波是指高斯函數作為濾波函數的濾波操作。
// 
// 鄰域運算元與線性鄰域濾波
// 鄰域運算元(局部運算元)是利用給定像素周圍的像素值決定此像素的最終輸出值的一種運算元。
// 而線性鄰域濾波就是一種常用的鄰域運算元，像素的輸出值取決於輸入像素的加權和。
// 鄰域運算元除了用於局部色調調整以外，還可以用於影像濾波，以實現影像的模糊和銳利化、
// 影像邊緣增強或者影像雜訊的去除。
// 
// 線性鄰域濾波
// 線性濾波處理的輸出像素值g(i, j)是輸入值f(i + k, j + l)的加權和，如下：
//               g(i, j) = SUMMATION(k,I)(f(i + k, j + I)*h(k, I))
// 其中的h(k, I)，我們稱為"核"，是濾波器的加權係數，及濾波器的"濾波係數"
// 
// 鄰域濾波可以視為一種卷積，卷積是透過兩個函數f和h生成第三個函數g的一種數學運算子
// 
# include <iostream>
# include "opencv2/core/core.hpp"
# include "opencv2/highgui/highgui.hpp"
# include "opencv2/imgproc/imgproc.hpp"

int main(){

    // Load the original image.
    std::string wd = "C:/Users/jeff/Desktop/ProjectTemplate/src/Example/app/OpenCV/ch6_imgproc/";
    cv::Mat image = cv::imread(wd + "NFS01.jpg");


    /* Box Filter */
    // Establish the window.
    cv::namedWindow("Original");
    cv::namedWindow("Box Filter (Processed)");
    cv::namedWindow("Blur Filter (Processed)");
    cv::namedWindow("Gaussian Blur Filter (Processed)");

    // Show the original plot.
    cv::imshow("Original", image);

    // Box Filter Process
    cv::Mat out1, out2, out3;
    cv::boxFilter(image, out1 , -1, cv::Size(5, 5));
    // 第一個參數代表輸入影像，待處理的圖片深度應為CV_8U、CV_16U、CV_16S、CV_32F以及CV_64F之一。
    // 第二個參數代表目標影像，需要和來源圖片(第一個參數)有一致的尺寸和類型。
    //          比如可以用cv::Mat::Clone，以來源影像為模板，來初始化得到如假包換的目標圖。
    // 第三個參數代表輸出影像的深度，-1代表使用原圖深度，即image.depth()。
    // 第四個參數代表kernel size，cv::Size(w, h)中w為像素寬度，h為像素高度。
    // 第五個參數(未列出)代表錨點(即被模糊的那個點)。注意它有預設值cv::Point(-1, -1)。
    //          如果這個點座標是負值的話，就表示取核心的中心為錨點，所以預設值表示這個錨點在核心的中心。
    // 第六個參數(未列出)代表核心是否被其區域正規化(normalized)了，預設值為true，當其為true的時候，
    //          方框濾波就變成了均值濾波，當其為false的時候，方框濾波用於計算每個像素鄰域內的積分特性，
    //          如：密集光流演算法(dense optical flow algorithms)中用到的影像倒數的協方差矩陣
    //          (covariance matrices of image derivaties)。
    // 第七個參數(未列出)用於推斷影像外部像素的某種邊界模式，一般不去管它。

    // Show the processed image.
    cv::imshow("Box Filter (Processed)", out1);

    /* Blur Filter Process */
    cv::blur(image, out2, cv::Size(7, 7));
    cv::imshow("Blur Filter (Processed)", out2);

    /* Gaussian Blur Filter Process */
    // * 高斯濾波是一種線性平滑濾波，可以消除高斯雜訊，廣泛應用於影像處理的減噪過程。
    // * 高斯濾波就是對整幅影像進行加權平均的過程，其操作為用一個模板(或稱卷積、遮罩)
    //   掃描影像中的每一個像素，用模板確定的鄰域內像素的加權平均灰階值去替代模板中心像素點的值。
    // * 雖然高斯濾波用起來的效率往往不是最高的，但大家常說高斯濾波是最有用的濾波操作。
    // * 高斯模糊也用於電腦視覺演算法中的預先處理階段，以增強影像在不同比例大小下的影像效果。
    // * 從數學角度來看，影像的高斯模糊過程就是影像與常態分布做卷積。
    // * 高斯模糊濾波器對於抑制服從常態分布的雜訊非常有效。
    // * 由於高斯函數的傅立葉變換是另一個高斯函數，所以高斯模糊對於影像來說就是一個低通濾波操作。
    // * 影像與圓形方框模糊做卷積將會產生更加精確的焦距外成像效果。
    cv::GaussianBlur(image, out3, cv::Size(3, 3), 0, 0);
    cv::imshow("Gaussian Blur Filter (Processed)", out3);

    cv::waitKey(0);
    
    // * FilterEngine類別為OpenCV影像濾波核心引擎(是關於影像濾波的主力軍類別)。
    //   各種濾波函數blur、GaussianBlur...，其實就是在函數末尾處定義了一個Ptr<FilterEngine>類型的f，
    //   然後f->apply(src, dst)了一下而已。這個類別可以把幾乎所有的濾波操作施加到影像上，它包含了
    //   所有必要的中間暫存器。有很多和濾波相關的create系函數的返回值直接就是Ptr<FilterEngine>，
    //   其中的Ptr是用來動態分配物件的智慧指標模板類別，而<>內的模板參數就是FilterEngine。
    //   使用FilterEngine類別可以分塊處理大量的影像，建構複雜的管線，其中就包含一些進行濾波階段。

    return 0;
}